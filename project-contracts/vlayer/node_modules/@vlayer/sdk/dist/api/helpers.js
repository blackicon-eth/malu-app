import { createTestClient, http, publicActions, walletActions, } from "viem";
import { privateKeyToAccount, generatePrivateKey } from "viem/accounts";
import { foundry } from "viem/chains";
const rpcUrls = new Map([[foundry.id, http()]]);
export const chainIds = [foundry.id];
export function createAnvilClient(chainId = foundry.id) {
    const transport = rpcUrls.get(chainId);
    if (transport == undefined) {
        throw Error(`No url for chainId ${chainId}`);
    }
    return createTestClient({
        chain: foundry,
        mode: "anvil",
        transport: transport,
    })
        .extend(publicActions)
        .extend(walletActions);
}
export async function deployContract(contractSpec, args = [], chainId = foundry.id) {
    const ethClient = createAnvilClient(chainId);
    const [deployer] = await ethClient.getAddresses();
    const txHash = await ethClient.deployContract({
        abi: contractSpec.abi,
        bytecode: contractSpec.bytecode.object,
        account: deployer,
        args,
        chain: foundry,
    });
    const receipt = await ethClient.waitForTransactionReceipt({ hash: txHash });
    if (receipt.status != "success") {
        throw new Error(`Contract deployment failed with status: ${receipt.status}`);
    }
    return receipt.contractAddress;
}
export async function deployProverVerifier(proverSpec, verifierSpec, args = {}, chainId = foundry.id) {
    console.log("Deploying prover");
    const proverAddress = await deployContract(proverSpec, args.prover ?? [], chainId);
    console.log(`Prover has been deployed on ${proverAddress} address`);
    console.log("Deploying verifier");
    const verifierAddress = await deployContract(verifierSpec, [proverAddress, ...(args.verifier ?? [])], chainId);
    console.log(`Verifier has been deployed on ${verifierAddress} address`);
    return [proverAddress, verifierAddress];
}
export async function call(abi, address, functionName, args, chainId = foundry.id) {
    const ethClient = createAnvilClient(chainId);
    return ethClient.readContract({
        abi,
        address,
        functionName,
        args,
    });
}
export async function writeContract(address, abi, functionName, args, sender, chain = foundry) {
    const ethClient = createAnvilClient(chain.id);
    const selectedSender = sender || (await ethClient.getAddresses())[0];
    const txHash = await ethClient.writeContract({
        address,
        abi: abi,
        functionName,
        args: args,
        chain,
        account: selectedSender,
        chainOverride: undefined,
    });
    const txReceipt = await ethClient.waitForTransactionReceipt({ hash: txHash });
    if (txReceipt.status != "success") {
        throw new Error(`Transaction failed with status: ${txReceipt.status}`);
    }
    return txReceipt;
}
export const getTestAccount = () => privateKeyToAccount(generatePrivateKey());
export const getTestAddresses = (chainId = foundry.id) => createAnvilClient(chainId).getAddresses();

import { type Abi, type Address, type Chain, type ContractFunctionArgs, type ContractFunctionName, type Hex, PublicClient, walletActions } from "viem";
import type { ContractSpec, ContractArg } from "./lib/types/ethereum.js";
export declare const chainIds: 31337[];
export declare function createAnvilClient(chainId?: number): ReturnType<typeof walletActions> & PublicClient;
export declare function deployContract(contractSpec: ContractSpec, args?: ContractArg[], chainId?: number): Promise<Address>;
type DeploySpec<T extends Abi> = {
    abi: T;
    bytecode: {
        object: Hex;
    };
};
type Tail<T> = T extends readonly [unknown, ...infer U] ? U : [];
export declare function deployProverVerifier<P extends Abi, V extends Abi>(proverSpec: DeploySpec<P>, verifierSpec: DeploySpec<V>, args?: {
    prover?: ContractArg[];
    verifier?: Tail<ContractArg>[];
}, chainId?: number): Promise<`0x${string}`[]>;
export declare function call<T extends Abi, F extends ContractFunctionName<T, "pure" | "view">>(abi: T, address: Address, functionName: F, args?: ContractFunctionArgs<T, "pure" | "view", F>, chainId?: number): Promise<import("viem").ContractFunctionReturnType<T, "pure" | "view", F, ContractFunctionArgs<T, "pure" | "view", F>>>;
export declare function writeContract<T extends Abi, F extends ContractFunctionName<T, "payable" | "nonpayable">>(address: Address, abi: T, functionName: F, args: ContractFunctionArgs<T, "payable" | "nonpayable", F>, sender?: Address, chain?: Chain): Promise<import("viem").TransactionReceipt>;
export declare const getTestAccount: () => {
    address: Address;
    nonceManager?: import("viem").NonceManager | undefined;
    sign: (parameters: {
        hash: import("viem").Hash;
    }) => Promise<Hex>;
    experimental_signAuthorization: (parameters: import("viem/experimental").Authorization) => Promise<import("viem/accounts").SignAuthorizationReturnType>;
    signMessage: ({ message }: {
        message: import("viem").SignableMessage;
    }) => Promise<Hex>;
    signTransaction: <serializer extends import("viem").SerializeTransactionFn<import("viem").TransactionSerializable> = import("viem").SerializeTransactionFn<import("viem").TransactionSerializable>, transaction extends Parameters<serializer>[0] = Parameters<serializer>[0]>(transaction: transaction, options?: {
        serializer?: serializer | undefined;
    } | undefined) => Promise<import("viem").IsNarrowable<import("viem").TransactionSerialized<import("viem").GetTransactionType<transaction>>, Hex> extends true ? import("viem").TransactionSerialized<import("viem").GetTransactionType<transaction>> : Hex>;
    signTypedData: <const typedData extends import("viem").TypedData | Record<string, unknown>, primaryType extends keyof typedData | "EIP712Domain" = keyof typedData>(parameters: import("viem").TypedDataDefinition<typedData, primaryType>) => Promise<Hex>;
    publicKey: Hex;
    source: "privateKey";
    type: "local";
};
export declare const getTestAddresses: (chainId?: number) => Promise<Address[]>;
export {};
